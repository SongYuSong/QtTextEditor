#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<iostream>
#include<fstream>
#include<dirent.h>
#include<sys/stat.h>
using namespace std;
#define MAXLEN 257
int is_dir(char* path){
	struct stat st;
	stat(path,&st);
	if(S_ISDIR(st.st_mode)){
		return 1;
	}
	else{
		return 0;
	}
}

int endwith(char* s,char c){
	if(s[strlen(s)-1]==c){
		return 1;
	}
	else{
		return 0;
	}
}

char* str_contact(char* str1,char* str2){
	char* result;
	result=(char*)malloc(strlen(str1)+strlen(str2)+1);
	if(!result){
		printf("字符串连接时，内存动态分配失败\n");
		exit(1);
	}
	strcat(result,str1);
	strcat(result,str2);
	return result;
}

void copy_file(char* source_path,char *backup_path){
	char buffer[1024];
	FILE *in,*out;
	if((in=fopen(source_path,"r"))==NULL){
		printf("源文件打开失败！\n");
		exit(1);
	}
	if((out=fopen(backup_path,"w"))==NULL){
		printf("目标文件创建失败！\n");
		exit(1);
	}
	int len;
	while((len=fread(buffer,1,1024,in))>0){
		fwrite(buffer,1,len,out);
	}
	fclose(out);
	fclose(in);
}
void copy_folder(char* source_path,char *backup_path){
	if(!opendir(backup_path)){
		if (mkdir(backup_path,0777))
		{
		    printf("创建文件夹失败！");
		}
	}
	char *path;
	path=(char*)malloc(512);
	path=str_contact(path,source_path);
	struct dirent* filename;
	DIR* dp=opendir(path);
	while(filename=readdir(dp)){
		memset(path,0,sizeof(path));
		path=str_contact(path,source_path);
		char *file_source_path;
		file_source_path=(char*)malloc(512);
		if(!endwith(source_path,'/')){
			file_source_path=str_contact(file_source_path,source_path);
			file_source_path=str_contact(source_path,"/");
		}
		else{
			file_source_path=str_contact(file_source_path,source_path);
		}
		char *file_backup_path;
		file_backup_path=(char*)malloc(512);
		if(!endwith(backup_path,'/')){
			file_backup_path=str_contact(file_backup_path,backup_path);
			file_backup_path=str_contact(backup_path,"/");
		}
		else{
			file_backup_path=str_contact(file_backup_path,backup_path);
		}
		file_source_path=str_contact(file_source_path,filename->d_name);
		file_backup_path=str_contact(file_backup_path,filename->d_name);
		if(is_dir(file_source_path)){
			if(!endwith(file_source_path,'.')){
				copy_folder(file_source_path,file_backup_path);
			}		
		}
		else{
			copy_file(file_source_path,file_backup_path);
			printf("复制%s到%s成功！\n",file_source_path,file_backup_path);
		}
	}	
}

int empty_dir(const char *path){
    DIR *dp;
    dp = opendir(path);
    if(dp == NULL){
        return -1;
    }
    if(readdir(dp) == NULL || readdir(dp) == NULL || readdir(dp) == NULL){
        closedir(dp);
        return 1;
    }
    return 0;
}

void remove_dir(char* source_path){
	char *path;
	path=(char*)malloc(512);
	path=str_contact(path,source_path);
	struct dirent* filename;
	DIR* dp=opendir(path);
	while(filename=readdir(dp)){
		memset(path,0,sizeof(path));
		path=str_contact(path,source_path);
		char *file_source_path;
		file_source_path=(char*)malloc(512);
		if(!endwith(source_path,'/')){
			file_source_path=str_contact(file_source_path,source_path);
			file_source_path=str_contact(source_path,"/");
		}
		else{
			file_source_path=str_contact(file_source_path,source_path);
		}
		file_source_path=str_contact(file_source_path,filename->d_name);
		if(is_dir(file_source_path)){
			if(!endwith(file_source_path,'.') && empty_dir(file_source_path)==0){
				remove_dir(file_source_path);
				remove(file_source_path);
			}
			else if(!endwith(file_source_path,'.') && empty_dir(file_source_path)==1){
				remove(file_source_path);
			}
		}
		else{
			remove(file_source_path);
		}
	}	
}

void returnback(char* source_path,char *backup_path){
	remove_dir(source_path);
	copy_folder(backup_path,source_path);
}

struct dir_file{
	char *filename="null";
	int typenum=0;
	dir_file *next=NULL;
};

void readfile(char *file_path,dir_file *d_f){
	char *path;
	path=(char*)malloc(512);
	path=str_contact(path,file_path);
	struct dirent* filename;
	DIR* dp=opendir(path);
	while(filename=readdir(dp)){
		memset(path,0,sizeof(path));
		path=str_contact(path,file_path);
		char *file_source_path;
		file_source_path=(char*)malloc(512);
		if(!endwith(file_path,'/')){
			file_source_path=str_contact(file_source_path,file_path);
			file_source_path=str_contact(file_path,"/");
		}
		else{
			file_source_path=str_contact(file_source_path,file_path);
		}
		file_source_path=str_contact(file_source_path,filename->d_name);
		if(is_dir(file_source_path)){
			if(!endwith(file_source_path,'.')){
			    dir_file *df=new dir_file();
				df->typenum=4;
				df->filename=filename->d_name;
				df->next=d_f->next;
				d_f->next=df;
				readfile(file_source_path,d_f);
			}
		}
		else{
			dir_file *df=new dir_file();
			df->typenum=8;
			df->filename=filename->d_name;
			df->next=d_f->next;
			d_f->next=df;
		}
	}	
}

void compare(char* source_path,char *backup_path){
	struct dir_file *d_f_source=new dir_file();
	struct dir_file *d_f_backup=new dir_file();
	readfile(source_path,d_f_source);
	readfile(backup_path,d_f_backup);
	FILE *fp1,*fp2;
	fp1=fopen("source_file.txt","w+");
	fp2=fopen("backup_file.txt","w+");
	while(d_f_source!=NULL){
		fprintf(fp1,"%s %d\n",d_f_source->filename,d_f_source->typenum);
		d_f_source=d_f_source->next;
	}
	while(d_f_backup!=NULL){
		fprintf(fp2,"%s %d\n",d_f_backup->filename,d_f_backup->typenum);
		d_f_backup=d_f_backup->next;
	}
	fclose(fp1);
	fclose(fp2);
	ifstream op;
	string str1,str2;
	op.open("source_file.txt");
	while(!op.eof()){
		str1+=op.get();
	}
	op.close();
	op.open("backup_file.txt");
	while(!op.eof()){
		str2+=op.get();
	}
	op.close();
	if(str1==str2){
		printf("文件校验结束，文件备份一致！");
	}
	else{
		printf("文件校验结束，文件备份不一致！");
	}
	return;
}

int main(int argc,char *argv[]){
	if(argv[1]==NULL||argv[2]==NULL){
		printf("请输入两个文件夹路径，第一个为源，第二个为目的！\n");
		exit(1);
	}
	char* source_path=argv[1];
	char* backup_path=argv[2];
	char* num=argv[3];
	DIR* source=opendir(source_path);
	DIR* destination=opendir(backup_path);
	if(!source||!destination){
		printf("你输入的一个参数或者第二个参数不是文件夹！\n");
	}
	if(num[0]=='c' && num[1]=='o' && num[2]=='p' && num[3]=='y'){
		copy_folder(source_path,backup_path);
	}
	else if(num[0]=='r' && num[1]=='e' && num[2]=='t' && num[3]=='u' && num[4]=='r' && num[5]=='n'){
		returnback(source_path,backup_path);
	}
	else if(num[0]=='c' && num[1]=='o' && num[2]=='m' && num[3]=='p' && num[4]=='a' && num[5]=='r' && num[6]=='e'){
		compare(source_path,backup_path);
	}
	return 0;
}
